{
    "Cpp Competitive c++initial": {
        "prefix": "@initial",
        "body": [
            "#include<bits/stdc++.h>",
            "#define all(v) begin(v), end(v)",
            "#define rall(v) rbegin(v), rend(v)",
            "#define uniq(v) sort(all(v));v.erase(unique(all(v)),end(v))",
            "#define ll long long",
            "#define bv vector<bool>",
            "#define iv vector<ll>",
            "#define ivv vector<iv>",
            "#define ip pair<ll, ll>",
            "#define rep(i, n) for(ll i=0; i<(ll)n; i++)",
            "#define nrep(i, n) for(ll i=1; i<(ll)n+1; i++)",
            "#define rrep(i, n) for(ll i=n-1; i>=0; i--)",
            "#define MOD 998244353",
            "#define INF 2e18",
            "using namespace std;",
            "// USEFUL FUNCTION",
            "template<class T>bool chmax(T&a,const T&b){return (a<b)&&(a=b,true);}",
            "template<class T>bool chmin(T&a,const T&b){return (a>b)&&(a=b,true);}",
            "template<class T>void print(T&a){for(auto v: a) cout << v << ' '; cout << endl;}",
            "template<class T1, class T2>void printmp(map<T1, T2> &mp){for(auto iter: mp) cout << iter.first << ':' << iter.second << endl;}",
            "template<class T>using Greater_pq=priority_queue<T,vector<T>,greater<T>>;",
            "// NUMERIC FUNCTION",
            "ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;}",
            "ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}",
            "map<ll, ll> numeric_component(ll N) {",
            "    map<ll, ll> res;",
            "    for (ll i = 2; i * i <= N; i++) {",
            "        if (N % i != 0) continue;",
            "        while (N % i == 0) {res[i]++; N /= i;}",
            "    }",
            "    if (N != 1) res[N]++;",
            "    return res;",
            "}",
            "// GRAPH FUNCTION",
            "struct UnionFind {",
            "    iv par, rank, siz, min_node;",
            "    UnionFind(int n) : par(n, -1), rank(n, 0), siz(n, 1) {}",
            "    int root(int x) {",
            "        if (par.at(x) == -1) return x;",
            "        else return par.at(x) = root(par.at(x));",
            "    }",
            "    bool is_same(int x, int y) {return root(x) == root(y);}",
            "    bool unite(int x, int y) {",
            "        int rx = root(x), ry = root(y);",
            "        if (is_same(x, y)) return false;",
            "        if (siz.at(rx) < siz.at(ry)) swap(rx, ry);",
            "        par.at(ry) = rx;",
            "        if (rank.at(rx) == rank.at(ry)) rank.at(rx) += 1;",
            "        siz.at(rx) += siz.at(ry);",
            "        return true;",
            "    }",
            "};",
            "// TREE FUNCTION",
            "template<class Monoid> struct SegTree {",
            "    using Func = function<Monoid(Monoid, Monoid)>;",
            "    // core member",
            "    int N;",
            "    Func OP;",
            "    Monoid IDENTITY;",
            "    // inner data",
            "    int offset;",
            "    vector<Monoid> dat;",
            "    // constructor",
            "    SegTree() {}",
            "    SegTree(int n, const Func &op, const Monoid &identity) {",
            "        init(n, op, identity);",
            "    }",
            "    SegTree(const vector<Monoid> &v, const Func &op, const Monoid &identity) {",
            "        init((int)v.size(), op, identity);",
            "        build(v);",
            "    }",
            "    void init(int n, const Func &op, const Monoid &identity) {",
            "        N = n;",
            "        OP = op;",
            "        IDENTITY = identity;",
            "        offset = 1;",
            "        while (offset < N) offset *= 2;",
            "        dat.assign(offset * 2, IDENTITY);",
            "    }",
            "    void init(const vector<Monoid> &v, const Func &op, const Monoid &identity) {",
            "        init((int)v.size(), op, identity);",
            "        build(v);",
            "    }",
            "    void build(const vector<Monoid> &v) {",
            "        assert(N == (int)v.size());",
            "        for (int i = 0; i < N; ++i) dat[i + offset] = v[i];",
            "        for (int k = offset - 1; k > 0; --k) dat[k] = OP(dat[k*2], dat[k*2+1]);",
            "    }",
            "    int size() const {",
            "        return N;",
            "    }",
            "    Monoid operator [] (int a) const { return dat[a + offset]; }",
            "    // 以下省略",
            "};",
            "// MODINV",
            "ll modinv(long long a, long long m) {",
            "    long long b = m, u = 1, v = 0;",
            "    while (b) {",
            "        long long t = a / b;",
            "        a -= t * b; swap(a, b);",
            "        u -= t * v; swap(u, v);",
            "    }",
            "    u %= m;",
            "    if (u < 0) u += m;",
            "    return u;",
            "}",
            "ll modfrac(ll a, ll b) {",
            "    return (a%MOD) * modinv(b, MOD) % MOD;",
            "}",
            "long long combi(long long n, long long k) {",
            "    if (n == k || k == 0)",
            "      return 1;",
            "    else {",
            "      return combi(n - 1, k - 1) + combi(n - 1, k);",
            "    }",
            "}",
            "// GRID",
            "iv di = {-1, 0, 0, 1};",
            "iv dj = {0, -1, 1, 0};",
            "iv di8 = {-1, -1, -1, 0, 0, 1, 1, 1};",
            "iv dj8 = {-1, 0, 1, -1, 1, -1, 0, 1};",
            "",
            "int main() {",
            "",
            "}"
        ],
        "description": "Cpp Competitive Programming"
    },
    "is_out": {
        "prefix": "@is_out",
        "body": [
            "auto is_out = [&](int i, int j) -> bool {",
            "    if(i < 0 or i >= H) return true;",
            "    if(j < 0 or j >= W) return true;",
            "    return false;",
            "};",
        ]
    },
    "gird-BFS": {
        "prefix": "@grid-dfs",
        "body": [
            "vector<vector<int>> checked(H, vector<int>(W, -1));",
            "checked[0][0] = 0;  // set start",
            "queue<pair<int, int>> q; q.push({si, sj});",
            "while (!q.empty()) {",
            "    int i, j;",
            "    tie(i, j) = q.front();",
            "    q.pop();",
            "    for (int k = 0; k < 4; ++k) {",
            "        int newi = i + di[k];",
            "        int newj = j + dj[k];",
            "",
            "        if (is_out(newi, newj))  continue;",
            "        if (checked[newi][newj] != -1) continue;",
            "        if (S[newi][newj] == '#') continue;",
            "",
            "        q.push({newi, newj});",
            "        checked[newi][newj] = checked[i][j] + 1;",
            "    }",
            "}"
        ],
        "description": "Calculate shortest path using BFS with initial setup"
    },
    "simple-init" : {
        "prefix": "@simple-init",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef long long ll;",
            "",
            "int main(){",
            "    $1",
            "}"
        ]
    },
    "poj-init" : {
        "prefix": "@poj-init",
        "body": [
            "#include <iostream>",
            "#include <vector>",
            "#include <string>",
            "#include <algorithm>",
            "using namespace std;",
            "typedef long long ll;",
            "",
            "int main(){",
            "    $1",
            "}"
        ]
    }
}
